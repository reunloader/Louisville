<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>{{ page.title }} | {{ site.title }}</title>
  <link rel="stylesheet" href="{{ "/assets/main.css" | relative_url }}">

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin="anonymous"/>

  <!-- Flatpickr CSS for date range picker -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">

  <style>
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    }
    .site-header {
      border-top: 5px solid #424242;
      border-bottom: 1px solid #e8e8e8;
      min-height: 55px;
      padding: 10px 0;
    }
    .site-header .wrapper {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .site-title {
      font-size: 26px;
      font-weight: 300;
      line-height: 54px;
      margin-bottom: 0;
      text-decoration: none;
      color: #424242;
    }
    .site-nav {
      display: flex;
      gap: 20px;
    }
    .site-nav a {
      color: #424242;
      text-decoration: none;
      line-height: 54px;
    }
    .site-nav a:hover {
      text-decoration: underline;
    }
    .wrapper {
      max-width: 1200px;
      margin: 0 auto;
      padding: 30px 20px;
    }
    #map {
      height: 600px;
      width: 100%;
      margin: 20px 0;
      border: 1px solid #ddd;
      border-radius: 5px;
    }
    .map-controls {
      margin: 20px 0;
      padding: 15px;
      background: #f5f5f5;
      border-radius: 5px;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 12px;
    }
    .map-controls .date-picker-row {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .map-controls label {
      font-weight: 500;
      font-size: 14px;
    }
    .map-controls input {
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
      min-width: 250px;
      cursor: pointer;
    }
    .map-controls input:hover {
      border-color: #999;
    }
    .map-controls button {
      padding: 8px 20px;
      background: #333;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
    }
    .map-controls button:hover {
      background: #555;
    }
    .popup-content {
      max-width: 300px;
    }
    .popup-content h3 {
      margin: 0 0 10px 0;
      font-size: 14px;
      color: #333;
    }
    .popup-content p {
      margin: 5px 0;
      font-size: 12px;
    }
    .popup-content a {
      color: #0066cc;
      text-decoration: none;
    }
    .popup-content a:hover {
      text-decoration: underline;
    }
    .loading {
      text-align: center;
      padding: 20px;
      font-size: 16px;
      color: #666;
    }
    .map-stats {
      margin: 10px 0;
      padding: 10px;
      background: #e8f4f8;
      border-left: 4px solid #0066cc;
      font-size: 14px;
    }
    .post-title {
      font-size: 42px;
      letter-spacing: -1px;
      line-height: 1;
      margin-bottom: 20px;
    }
    .legend {
      background: white;
      padding: 10px;
      border-radius: 5px;
      box-shadow: 0 0 15px rgba(0,0,0,0.2);
      line-height: 24px;
      font-size: 14px;
    }
    .legend h4 {
      margin: 0 0 8px 0;
      font-size: 14px;
      font-weight: bold;
    }
    .legend i {
      width: 18px;
      height: 18px;
      float: left;
      margin-right: 8px;
      border-radius: 50%;
    }
    .legend .legend-item {
      margin-bottom: 5px;
      display: flex;
      align-items: center;
    }
  </style>
</head>
<body>
  <header class="site-header">
    <div class="wrapper">
      <a class="site-title" href="{{ "/" | relative_url }}">{{ site.title }}</a>
      <nav class="site-nav">
        <a href="{{ "/" | relative_url }}">Live Feed</a>
        <a href="{{ "/digest/" | relative_url }}">Digest</a>
        <a href="{{ "/map/" | relative_url }}">Map</a>
        <a href="{{ "/about/" | relative_url }}">About</a>
      </nav>
    </div>
  </header>

  <main class="page-content">
    <div class="wrapper">
      <article class="post">
        <header class="post-header">
          <h1 class="post-title">{{ page.title }}</h1>
        </header>

        <div class="post-content">
          {{ content }}

          <div class="map-controls">
            <div class="date-picker-row">
              <label for="dateRange">Date Range:</label>
              <input type="text" id="dateRange" placeholder="Select date or date range...">
            </div>
            <button onclick="resetFilters()">Show All</button>
          </div>

          <div id="stats" class="map-stats" style="display:none;"></div>
          <div id="loading" class="loading">Loading map and geocoding addresses...</div>
          <div id="map"></div>
        </div>
      </article>
    </div>
  </main>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin="anonymous"></script>

  <!-- Flatpickr JS for date range picker -->
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

  <script>
    // Store all events data
    const eventsData = [
      {% for post in site.posts limit:500 %}
      {% unless post.categories contains 'daily-digest' %}
      {
        title: {{ post.title | jsonify }},
        date: "{{ post.date | date: '%Y-%m-%d' }}",
        datetime: "{{ post.date | date: '%Y-%m-%d %H:%M' }}",
        categories: {{ post.categories | jsonify }},
        tags: {{ post.tags | jsonify }},
        status: {{ post.status | jsonify }},
        content: {{ post.content | strip_html | jsonify }},
        url: "{{ post.url | relative_url }}"
      }{% unless forloop.last %},{% endunless %}
      {% endunless %}
      {% endfor %}
    ];

    let map;
    let markers = [];
    let markerLayer;
    let dateRangePicker;

    // Extract addresses from event content
    function extractAddresses(content) {
      const addresses = [];

      // Pattern 1: "block of Street Name" (e.g., "100 block of Sears Ave")
      const blockPattern = /(\d+)\s+block\s+of\s+([^â€“\n]+?)(?=\s*â€“|\s*\n|$)/gi;

      // Pattern 2: "Street and Street" intersections
      const intersectionPattern = /([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*\s+(?:Street|St|Avenue|Ave|Road|Rd|Boulevard|Blvd|Drive|Dr|Parkway|Pky|Lane|Ln))\s+and\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*\s+(?:Street|St|Avenue|Ave|Road|Rd|Boulevard|Blvd|Drive|Dr|Parkway|Pky|Lane|Ln))/gi;

      // Pattern 3: Full addresses (e.g., "4512 Tray Place")
      const fullAddressPattern = /\b(\d+)\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*\s+(?:Place|Street|St|Avenue|Ave|Road|Rd|Boulevard|Blvd|Drive|Dr|Parkway|Pky|Lane|Ln))\b/g;

      let match;

      // Extract block addresses
      while ((match = blockPattern.exec(content)) !== null) {
        addresses.push(`${match[1]} ${match[2].trim()}, Louisville, KY`);
      }

      // Extract intersections
      while ((match = intersectionPattern.exec(content)) !== null) {
        addresses.push(`${match[1].trim()} and ${match[2].trim()}, Louisville, KY`);
      }

      // Extract full addresses (if not already captured)
      while ((match = fullAddressPattern.exec(content)) !== null) {
        const addr = `${match[1]} ${match[2].trim()}, Louisville, KY`;
        if (!addresses.some(a => a.includes(match[2].trim()))) {
          addresses.push(addr);
        }
      }

      return [...new Set(addresses)]; // Remove duplicates
    }

    // Custom marker icons
    const markerIcons = {
      red: L.icon({
        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        shadowSize: [41, 41]
      }),
      blue: L.icon({
        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png',
        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        shadowSize: [41, 41]
      }),
      yellow: L.icon({
        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-yellow.png',
        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        shadowSize: [41, 41]
      })
    };

    // Server-side geocoded addresses (pre-computed during build)
    const serverGeocodeData = {{ site.data.geocoded_addresses | jsonify }};

    // Geocode cache using localStorage (fallback for new addresses)
    const GEOCODE_CACHE_KEY = 'derby_city_watch_geocode_cache';
    const CACHE_VERSION = '1';

    function getGeocodeCache() {
      try {
        const cached = localStorage.getItem(GEOCODE_CACHE_KEY);
        if (cached) {
          const data = JSON.parse(cached);
          if (data.version === CACHE_VERSION) {
            return data.cache || {};
          }
        }
      } catch (e) {
        console.warn('Failed to load geocode cache:', e);
      }
      return {};
    }

    function saveGeocodeCache(cache) {
      try {
        localStorage.setItem(GEOCODE_CACHE_KEY, JSON.stringify({
          version: CACHE_VERSION,
          cache: cache,
          updated: new Date().toISOString()
        }));
      } catch (e) {
        console.warn('Failed to save geocode cache:', e);
      }
    }

    // Merge server-side and browser-side caches
    let geocodeCache = { ...serverGeocodeData, ...getGeocodeCache() };
    console.log(`Loaded ${Object.keys(serverGeocodeData).length} server-cached and ${Object.keys(getGeocodeCache()).length} browser-cached addresses`);

    // Geocode using Nominatim (OpenStreetMap) with caching
    async function geocodeAddress(address) {
      // Check cache first
      if (geocodeCache[address]) {
        return geocodeCache[address];
      }

      try {
        const response = await fetch(
          `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}&limit=1`,
          {
            headers: {
              'User-Agent': 'Derby City Watch Event Map'
            }
          }
        );
        const data = await response.json();

        if (data && data.length > 0) {
          const coords = {
            lat: parseFloat(data[0].lat),
            lng: parseFloat(data[0].lon)
          };
          // Cache the result
          geocodeCache[address] = coords;
          saveGeocodeCache(geocodeCache);
          return coords;
        }
        // Cache null results too to avoid re-trying failed addresses
        geocodeCache[address] = null;
        saveGeocodeCache(geocodeCache);
        return null;
      } catch (error) {
        console.error(`Geocoding error for ${address}:`, error);
        return null;
      }
    }

    // Extract specific event detail for an address
    function extractEventDetail(content, address) {
      // Remove the ", Louisville, KY" suffix for matching
      const searchAddr = address.replace(', Louisville, KY', '');

      // Extract just the street number and first few words of street name for flexible matching
      // e.g., "1800 South 3rd" from "1800 South 3rd Street"
      const addrMatch = searchAddr.match(/^(\d+)\s+(.+?)(?:\s+(?:Street|St|Avenue|Ave|Road|Rd|Boulevard|Blvd|Drive|Dr|Parkway|Pky|Lane|Ln|Place))?$/i);

      let searchPatterns = [searchAddr];
      if (addrMatch) {
        const streetNum = addrMatch[1];
        const streetName = addrMatch[2];
        // Add pattern with "block of"
        searchPatterns.push(`${streetNum} block of ${streetName}`);
        // Add just street number + first word of street
        searchPatterns.push(`${streetNum} ${streetName.split(' ')[0]}`);
      }

      // Split content into lines
      const lines = content.split('\n');

      // Find the line containing this address using any of our search patterns
      for (let line of lines) {
        for (let pattern of searchPatterns) {
          if (line.toLowerCase().includes(pattern.toLowerCase())) {
            // Remove emoji and clean up the line
            let detail = line.replace(/[ðŸ”¥ðŸ¥ðŸš¨ðŸš”ðŸš‘âš ï¸ðŸ“]/g, '').trim();
            // Remove markdown bold markers
            detail = detail.replace(/\*\*/g, '');
            // Remove leading/trailing dashes
            detail = detail.replace(/^â€“\s*|\s*â€“$/g, '').trim();
            return detail;
          }
        }
      }

      // If no specific line found, return first non-empty line
      for (let line of lines) {
        const cleaned = line.replace(/[ðŸ”¥ðŸ¥ðŸš¨ðŸš”ðŸš‘âš ï¸ðŸ“]/g, '').replace(/\*\*/g, '').trim();
        if (cleaned.length > 10) {
          return cleaned.substring(0, 150) + (cleaned.length > 150 ? '...' : '');
        }
      }

      return 'Event details available in full report';
    }

    // Create marker for event with coordinates
    function createMarkerWithCoords(event, address, coords) {
      // Determine marker color based on category
      let markerIcon = markerIcons.blue; // default (police)
      if (event.categories.includes('medical')) markerIcon = markerIcons.yellow;
      else if (event.categories.includes('fire-&-rescue')) markerIcon = markerIcons.red;
      else if (event.categories.includes('Police')) markerIcon = markerIcons.blue;

      const marker = L.marker([coords.lat, coords.lng], { icon: markerIcon });

      // Extract specific event detail for this location
      const eventDetail = extractEventDetail(event.content, address);

      // Create popup content
      const popupContent = `
        <div class="popup-content">
          <h3>${event.datetime}</h3>
          <p><strong>Location:</strong> ${address}</p>
          <p>${eventDetail}</p>
          <p><a href="${event.url}" target="_blank">View Full Report</a></p>
        </div>
      `;

      marker.bindPopup(popupContent);

      // Store event data with marker
      marker.eventData = event;
      marker.eventAddress = address;

      markers.push(marker);
      marker.addTo(markerLayer);
    }

    // Geocode a single address with delay
    async function geocodeWithDelay(address, delayMs) {
      await new Promise(resolve => setTimeout(resolve, delayMs));
      return await geocodeAddress(address);
    }

    // Update stats display
    function updateStats() {
      const visibleMarkers = markers.filter(marker => markerLayer.hasLayer(marker));
      document.getElementById('stats').innerHTML =
        `<strong>Showing:</strong> ${visibleMarkers.length} of ${markers.length} locations`;
    }

    // Initialize map
    async function initMap() {
      // Center on Louisville, KY
      map = L.map('map').setView([38.2527, -85.7585], 12);

      // Add OpenStreetMap tiles
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
        maxZoom: 19
      }).addTo(map);

      // Add legend
      const legend = L.control({position: 'bottomright'});
      legend.onAdd = function(map) {
        const div = L.DomUtil.create('div', 'legend');
        div.innerHTML = `
          <h4>Event Categories</h4>
          <div class="legend-item">
            <i style="background: #2A81CB"></i>
            <span>Police</span>
          </div>
          <div class="legend-item">
            <i style="background: #CB2B3E"></i>
            <span>Fire & Rescue</span>
          </div>
          <div class="legend-item">
            <i style="background: #FFD326"></i>
            <span>Medical</span>
          </div>
        `;
        return div;
      };
      legend.addTo(map);

      // Create a layer group for markers
      markerLayer = L.layerGroup().addTo(map);

      // Process all events
      let allItems = [];

      eventsData.forEach(event => {
        const addresses = extractAddresses(event.content);
        addresses.forEach(address => {
          allItems.push({ event, address });
        });
      });

      console.log(`Found ${allItems.length} addresses from ${eventsData.length} events`);

      // Separate cached and uncached addresses
      const cachedItems = [];
      const uncachedItems = [];

      allItems.forEach(item => {
        if (geocodeCache[item.address]) {
          cachedItems.push(item);
        } else {
          uncachedItems.push(item);
        }
      });

      console.log(`Cached: ${cachedItems.length}, Need to geocode: ${uncachedItems.length}`);

      // Process cached addresses immediately (no API calls needed)
      cachedItems.forEach(item => {
        const coords = geocodeCache[item.address];
        if (coords) {
          createMarkerWithCoords(item.event, item.address, coords);
        }
      });

      // Apply initial filters to cached markers
      applyFilters();

      // Process uncached addresses with delay (respecting rate limits)
      if (uncachedItems.length > 0) {
        for (let i = 0; i < uncachedItems.length; i++) {
          const item = uncachedItems[i];

          // Add delay only for new geocoding requests (1 per second)
          const coords = await geocodeWithDelay(item.address, i * 1000);

          if (coords) {
            createMarkerWithCoords(item.event, item.address, coords);

            // Apply filters after each new marker
            applyFilters();
          }
        }
      }

      // Hide loading and show stats when done
      setTimeout(() => {
        document.getElementById('loading').style.display = 'none';
        document.getElementById('stats').style.display = 'block';
        updateStats();
      }, uncachedItems.length > 0 ? 1000 : 100);

      // Initialize date range picker
      const today = new Date();
      const weekAgo = new Date(today.getTime() - 7 * 24 * 60 * 60 * 1000);

      dateRangePicker = flatpickr("#dateRange", {
        mode: "range",
        dateFormat: "M j, Y",
        defaultDate: [weekAgo, today],
        maxDate: "today",
        allowInput: false,
        clickOpens: true,
        onChange: function(selectedDates, dateStr, instance) {
          applyFilters();
        }
      });

      // Initial filter application
      applyFilters();
    }

    // Filter markers based on date range
    function applyFilters() {
      if (!dateRangePicker) return;

      const selectedDates = dateRangePicker.selectedDates;

      markers.forEach(marker => {
        const event = marker.eventData;
        let show = true;

        // Date filter - handle both range and single day selection
        if (selectedDates.length > 0) {
          const eventDate = new Date(event.date);

          if (selectedDates.length === 1) {
            // Single day selected
            const selectedDay = new Date(selectedDates[0]);
            selectedDay.setHours(0, 0, 0, 0);
            const nextDay = new Date(selectedDay);
            nextDay.setDate(nextDay.getDate() + 1);

            if (eventDate < selectedDay || eventDate >= nextDay) {
              show = false;
            }
          } else if (selectedDates.length === 2) {
            // Date range selected
            const startDate = new Date(selectedDates[0]);
            const endDate = new Date(selectedDates[1]);
            endDate.setHours(23, 59, 59, 999); // Include the end date

            if (eventDate < startDate || eventDate > endDate) {
              show = false;
            }
          }
        }

        if (show) {
          marker.addTo(markerLayer);
        } else {
          markerLayer.removeLayer(marker);
        }
      });

      updateStats();
    }

    // Reset all filters
    function resetFilters() {
      if (dateRangePicker) {
        dateRangePicker.clear();
      }

      // Show all markers
      markers.forEach(marker => {
        marker.addTo(markerLayer);
      });

      updateStats();
    }

    // Initialize map when page loads
    document.addEventListener('DOMContentLoaded', initMap);
  </script>
</body>
</html>
