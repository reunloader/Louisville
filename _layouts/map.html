<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>{{ page.title }} | {{ site.title }}</title>
  <link rel="stylesheet" href="{{ "/assets/main.css" | relative_url }}">

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin="anonymous"/>

  <style>
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    }
    .site-header {
      border-top: 5px solid #424242;
      border-bottom: 1px solid #e8e8e8;
      min-height: 55px;
      padding: 10px 0;
    }
    .site-header .wrapper {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .site-title {
      font-size: 26px;
      font-weight: 300;
      line-height: 54px;
      margin-bottom: 0;
      text-decoration: none;
      color: #424242;
    }
    .site-nav {
      display: flex;
      gap: 20px;
    }
    .site-nav a {
      color: #424242;
      text-decoration: none;
      line-height: 54px;
    }
    .site-nav a:hover {
      text-decoration: underline;
    }
    /* Mobile hamburger menu */
    .menu-icon {
      display: none;
      cursor: pointer;
      flex-direction: column;
      gap: 5px;
    }
    .menu-icon span {
      width: 25px;
      height: 3px;
      background-color: #424242;
      transition: all 0.3s;
    }
    @media screen and (max-width: 768px) {
      .menu-icon {
        display: flex;
      }
      .site-nav {
        position: absolute;
        top: 60px;
        right: 0;
        background: white;
        flex-direction: column;
        width: 200px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        display: none;
        gap: 0;
        padding: 10px 0;
      }
      .site-nav.active {
        display: flex;
      }
      .site-nav a {
        padding: 10px 20px;
        line-height: normal;
      }
      .site-header .wrapper {
        position: relative;
      }
    }
    .wrapper {
      max-width: 1200px;
      margin: 0 auto;
      padding: 30px 20px;
    }
    #map {
      height: 600px;
      width: 100%;
      margin: 20px 0;
      border: 1px solid #ddd;
      border-radius: 5px;
    }
    .map-controls {
      margin: 20px 0;
      padding: 15px;
      background: #f5f5f5;
      border-radius: 5px;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 12px;
    }
    .map-controls .date-picker-row {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .map-controls label {
      font-weight: 500;
      font-size: 14px;
    }
    .map-controls input[type="date"] {
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
      min-width: 150px;
    }
    .map-controls input:hover {
      border-color: #999;
    }
    .map-controls button {
      padding: 8px 20px;
      background: #333;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
    }
    .map-controls button:hover {
      background: #555;
    }
    .popup-content {
      max-width: 300px;
    }
    .popup-content h3 {
      margin: 0 0 10px 0;
      font-size: 14px;
      color: #333;
    }
    .popup-content p {
      margin: 5px 0;
      font-size: 12px;
    }
    .popup-content a {
      color: #0066cc;
      text-decoration: none;
    }
    .popup-content a:hover {
      text-decoration: underline;
    }
    .map-stats {
      margin: 10px 0;
      padding: 10px;
      background: #e8f4f8;
      border-left: 4px solid #0066cc;
      font-size: 14px;
    }
    .post-title {
      font-size: 42px;
      letter-spacing: -1px;
      line-height: 1;
      margin-bottom: 20px;
    }
    .legend {
      background: white;
      padding: 10px;
      border-radius: 5px;
      box-shadow: 0 0 15px rgba(0,0,0,0.2);
      line-height: 24px;
      font-size: 14px;
    }
    .legend h4 {
      margin: 0 0 8px 0;
      font-size: 14px;
      font-weight: bold;
    }
    .legend i {
      width: 18px;
      height: 18px;
      float: left;
      margin-right: 8px;
      border-radius: 50%;
    }
    .legend .legend-item {
      margin-bottom: 5px;
      display: flex;
      align-items: center;
    }
  </style>
</head>
<body>
  <header class="site-header">
    <div class="wrapper">
      <a class="site-title" href="{{ "/" | relative_url }}">{{ site.title }}</a>
      <div class="menu-icon" onclick="toggleMenu()">
        <span></span>
        <span></span>
        <span></span>
      </div>
      <nav class="site-nav" id="navMenu">
        <a href="{{ "/" | relative_url }}">Live Feed</a>
        <a href="{{ "/map/" | relative_url }}">Map</a>
        <a href="{{ "/digest/" | relative_url }}">Digest</a>
        <a href="{{ "/chatbot/" | relative_url }}">Chatbot</a>
        <a href="{{ "/about/" | relative_url }}">About</a>
      </nav>
    </div>
  </header>

  <main class="page-content">
    <div class="wrapper">
      <article class="post">
        <header class="post-header">
          <h1 class="post-title">{{ page.title }}</h1>
        </header>

        <div class="post-content">
          {{ content }}

          <div class="map-controls">
            <div class="date-picker-row">
              <label for="startDate">From:</label>
              <input type="date" id="startDate">
              <label for="endDate">To:</label>
              <input type="date" id="endDate">
            </div>
            <div style="display: flex; gap: 10px;">
              <button onclick="resetFilters()">Show All</button>
              <button onclick="showMyLocation()">üìç My Location</button>
            </div>
          </div>

          <div id="stats" class="map-stats" style="display:none;"></div>
          <div id="map"></div>
        </div>
      </article>
    </div>
  </main>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin="anonymous"></script>

  <script>
    // Toggle mobile menu
    function toggleMenu() {
      const navMenu = document.getElementById('navMenu');
      navMenu.classList.toggle('active');
    }

    // Close menu when clicking outside
    document.addEventListener('click', function(event) {
      const navMenu = document.getElementById('navMenu');
      const menuIcon = document.querySelector('.menu-icon');

      if (navMenu && menuIcon) {
        const isClickInsideNav = navMenu.contains(event.target);
        const isClickOnIcon = menuIcon.contains(event.target);

        if (!isClickInsideNav && !isClickOnIcon && navMenu.classList.contains('active')) {
          navMenu.classList.remove('active');
        }
      }
    });

    // Store all events data
    const eventsData = [
      {% for post in site.posts limit:1000 %}
      {% unless post.categories contains 'daily-digest' %}
      {
        title: {{ post.title | jsonify }},
        date: "{{ post.date | date: '%Y-%m-%d' }}",
        datetime: "{{ post.date | date: '%Y-%m-%d %H:%M' }}",
        categories: {{ post.categories | jsonify }},
        tags: {{ post.tags | jsonify }},
        status: {{ post.status | jsonify }},
        content: {{ post.content | strip_html | jsonify }},
        url: "{{ post.url | relative_url }}"
      }{% unless forloop.last %},{% endunless %}
      {% endunless %}
      {% endfor %}
    ];

    let map;
    let markers = [];
    let markerLayer;

    // Extract addresses from event content
    function extractAddresses(content) {
      const addresses = [];

      // Pattern 1: "block of Street Name" (e.g., "100 block of Sears Ave")
      const blockPattern = /(\d+)\s+block\s+of\s+([^‚Äì\n,.]+?)(?=\s*[,.]|\s*‚Äì|\s*\n|$)/gi;

      // Pattern 2: "Street and Street" intersections
      const intersectionPattern = /([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*\s+(?:Street|St|Avenue|Ave|Road|Rd|Boulevard|Blvd|Drive|Dr|Parkway|Pky|Lane|Ln))\s+and\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*\s+(?:Street|St|Avenue|Ave|Road|Rd|Boulevard|Blvd|Drive|Dr|Parkway|Pky|Lane|Ln))/gi;

      // Pattern 3: Full addresses (e.g., "4512 Tray Place")
      const fullAddressPattern = /\b(\d+)\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*\s+(?:Place|Street|St|Avenue|Ave|Road|Rd|Boulevard|Blvd|Drive|Dr|Parkway|Pky|Lane|Ln))\b/g;

      let match;

      // Extract block addresses
      while ((match = blockPattern.exec(content)) !== null) {
        addresses.push(`${match[1]} ${match[2].trim()}, Louisville, KY`);
      }

      // Extract intersections
      while ((match = intersectionPattern.exec(content)) !== null) {
        addresses.push(`${match[1].trim()} and ${match[2].trim()}, Louisville, KY`);
      }

      // Extract full addresses (if not already captured)
      while ((match = fullAddressPattern.exec(content)) !== null) {
        const addr = `${match[1]} ${match[2].trim()}, Louisville, KY`;
        if (!addresses.some(a => a.includes(match[2].trim()))) {
          addresses.push(addr);
        }
      }

      return [...new Set(addresses)]; // Remove duplicates
    }

    // Custom marker icons
    const markerIcons = {
      red: L.icon({
        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        shadowSize: [41, 41]
      }),
      blue: L.icon({
        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png',
        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        shadowSize: [41, 41]
      }),
      yellow: L.icon({
        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-yellow.png',
        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        shadowSize: [41, 41]
      })
    };

    // Server-side geocoded addresses (pre-computed during build)
    const serverGeocodeData = {{ site.data.geocoded_addresses | jsonify }};

    // Geocode cache using localStorage (fallback for new addresses)
    const GEOCODE_CACHE_KEY = 'derby_city_watch_geocode_cache';
    const CACHE_VERSION = '1';

    function getGeocodeCache() {
      try {
        const cached = localStorage.getItem(GEOCODE_CACHE_KEY);
        if (cached) {
          const data = JSON.parse(cached);
          if (data.version === CACHE_VERSION) {
            return data.cache || {};
          }
        }
      } catch (e) {
        console.warn('Failed to load geocode cache:', e);
      }
      return {};
    }

    function saveGeocodeCache(cache) {
      try {
        localStorage.setItem(GEOCODE_CACHE_KEY, JSON.stringify({
          version: CACHE_VERSION,
          cache: cache,
          updated: new Date().toISOString()
        }));
      } catch (e) {
        console.warn('Failed to save geocode cache:', e);
      }
    }

    // Merge server-side and browser-side caches
    let geocodeCache = { ...serverGeocodeData, ...getGeocodeCache() };
    console.log(`Loaded ${Object.keys(serverGeocodeData).length} server-cached and ${Object.keys(getGeocodeCache()).length} browser-cached addresses`);

    // Geocode using Nominatim (OpenStreetMap) with caching
    async function geocodeAddress(address) {
      // Check cache first
      if (geocodeCache[address]) {
        return geocodeCache[address];
      }

      try {
        const response = await fetch(
          `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}&limit=1`,
          {
            headers: {
              'User-Agent': 'Derby City Watch Event Map'
            }
          }
        );
        const data = await response.json();

        if (data && data.length > 0) {
          const coords = {
            lat: parseFloat(data[0].lat),
            lng: parseFloat(data[0].lon)
          };
          // Cache the result
          geocodeCache[address] = coords;
          saveGeocodeCache(geocodeCache);
          return coords;
        }
        // Cache null results too to avoid re-trying failed addresses
        geocodeCache[address] = null;
        saveGeocodeCache(geocodeCache);
        return null;
      } catch (error) {
        console.error(`Geocoding error for ${address}:`, error);
        return null;
      }
    }

    // Remove all emojis and special characters from text
    function removeEmojis(text) {
      // Remove all emoji characters using comprehensive regex
      return text.replace(/[\u{1F000}-\u{1F9FF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}\u{1F300}-\u{1F5FF}\u{1F600}-\u{1F64F}\u{1F680}-\u{1F6FF}\u{1F900}-\u{1F9FF}\u{1FA70}-\u{1FAFF}\u{FE00}-\u{FE0F}\u{200D}]/gu, '');
    }

    // Extract specific event detail for an address
    function extractEventDetail(content, address) {
      // Remove the ", Louisville, KY" suffix for matching
      const searchAddr = address.replace(', Louisville, KY', '');

      // Extract just the street name for broader matching
      // e.g., "East Broadway" from "1200 East Broadway"
      const addrMatch = searchAddr.match(/^(\d+)\s+(.+?)(?:\s+(?:Street|St|Avenue|Ave|Road|Rd|Boulevard|Blvd|Drive|Dr|Parkway|Pky|Lane|Ln|Place))?$/i);

      let searchPatterns = [searchAddr];
      if (addrMatch) {
        const streetNum = addrMatch[1];
        const streetName = addrMatch[2];
        // Add pattern with "block of"
        searchPatterns.push(`${streetNum} block of ${streetName}`);
        // Add just street number + first word of street
        searchPatterns.push(`${streetNum} ${streetName.split(' ')[0]}`);
        // Add just street name (without number) for summary lines like "‚Äì East Broadway ‚Äì"
        searchPatterns.push(streetName);
      }

      // Split content into lines
      const lines = content.split('\n');

      // First pass: Look for summary lines (containing " ‚Äì ") that match the address
      for (let line of lines) {
        if (line.includes(' ‚Äì ')) {  // This is likely a summary line
          for (let pattern of searchPatterns) {
            if (line.toLowerCase().includes(pattern.toLowerCase())) {
              // Remove all emojis and clean up the line
              let detail = removeEmojis(line).trim();
              // Remove markdown bold markers
              detail = detail.replace(/\*\*/g, '');
              // Remove leading/trailing dashes
              detail = detail.replace(/^‚Äì\s*|\s*‚Äì$/g, '').trim();
              return detail;
            }
          }
        }
      }

      // Second pass: Look for any line containing the address (fallback)
      for (let line of lines) {
        for (let pattern of searchPatterns) {
          if (line.toLowerCase().includes(pattern.toLowerCase())) {
            // Remove all emojis and clean up the line
            let detail = removeEmojis(line).trim();
            // Remove markdown bold markers
            detail = detail.replace(/\*\*/g, '');
            // Remove leading/trailing dashes
            detail = detail.replace(/^‚Äì\s*|\s*‚Äì$/g, '').trim();
            return detail;
          }
        }
      }

      // If no specific line found, return first non-empty line
      for (let line of lines) {
        const cleaned = removeEmojis(line).replace(/\*\*/g, '').trim();
        if (cleaned.length > 10) {
          return cleaned.substring(0, 150) + (cleaned.length > 150 ? '...' : '');
        }
      }

      return 'Event details available in full report';
    }

    // Detect category from content
    function detectCategory(content) {
      const contentLower = content.toLowerCase();

      // Medical keywords (including mental health)
      const medicalKeywords = [
        'medical', 'ems', 'ambulance', 'overdose', 'cardiac', 'stroke',
        'injury', 'injured', 'sick', 'mental health', 'crisis', 'suicide',
        'unconscious', 'breathing', 'chest pain', 'seizure', 'fall victim'
      ];
      if (medicalKeywords.some(keyword => contentLower.includes(keyword))) {
        return 'medical';
      }

      // Fire keywords
      const fireKeywords = ['fire', 'structure fire', 'brush fire', 'smoke', 'alarm fire', 'vehicle fire'];
      if (fireKeywords.some(keyword => contentLower.includes(keyword))) {
        return 'fire';
      }

      // Everything else is police (suspicious activity, burglary, assault, traffic, etc.)
      return 'police';
    }

    // Extract event type and time from detail string
    function parseEventDetail(detail) {
      // Pattern: "Event Type ‚Äì address ‚Äì time"
      // We want to extract just the event type and time, removing the address

      // Split by " ‚Äì " to get parts
      const parts = detail.split(' ‚Äì ');

      if (parts.length >= 3) {
        // First part is event type, last part is time
        const eventType = parts[0].trim();
        const time = parts[parts.length - 1].trim();
        return { eventType, time };
      } else if (parts.length === 2) {
        // Just event type and either address or time
        return { eventType: parts[0].trim(), time: null };
      }

      // Fallback: return as-is
      return { eventType: detail, time: null };
    }

    // Extract descriptive text that appears after the specific event summary line
    function extractDescription(content, address) {
      // Remove the ", Louisville, KY" suffix for matching
      const searchAddr = address.replace(', Louisville, KY', '');

      // Build search patterns to find the event summary line
      const addrMatch = searchAddr.match(/^(\d+)\s+(.+?)(?:\s+(?:Street|St|Avenue|Ave|Road|Rd|Boulevard|Blvd|Drive|Dr|Parkway|Pky|Lane|Ln|Place))?$/i);

      let searchPatterns = [searchAddr];
      if (addrMatch) {
        const streetNum = addrMatch[1];
        const streetName = addrMatch[2];
        searchPatterns.push(`${streetNum} block of ${streetName}`);
        searchPatterns.push(`${streetNum} ${streetName.split(' ')[0]}`);
        // Add just street name (without number) for summary lines like "‚Äì East Broadway ‚Äì"
        searchPatterns.push(streetName);
      }

      // Split content into lines
      const lines = content.split('\n');

      // Find the index of the event summary line (prioritize lines with " ‚Äì ")
      let eventLineIndex = -1;

      // First pass: Look for summary lines (containing " ‚Äì ")
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        if (line.includes(' ‚Äì ')) {
          for (let pattern of searchPatterns) {
            if (line.toLowerCase().includes(pattern.toLowerCase())) {
              eventLineIndex = i;
              break;
            }
          }
          if (eventLineIndex !== -1) break;
        }
      }

      // Second pass: Look for any line with the address (fallback)
      if (eventLineIndex === -1) {
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];
          for (let pattern of searchPatterns) {
            if (line.toLowerCase().includes(pattern.toLowerCase())) {
              eventLineIndex = i;
              break;
            }
          }
          if (eventLineIndex !== -1) break;
        }
      }

      // Generic closing phrases to exclude
      const excludePhrases = [
        'we will post our full 24-hour summary',
        'look out for one another',
        'stay safe',
        'stay vigilant',
        'errors in transcription or interpretation may occur',
        'information provided is for community awareness'
      ];

      // If we found the event line, look for description lines right after it
      if (eventLineIndex !== -1) {
        const descriptionLines = [];

        // Start looking from the line after the event summary
        for (let i = eventLineIndex + 1; i < lines.length; i++) {
          const cleaned = removeEmojis(lines[i]).replace(/\*\*/g, '').trim();

          // Skip empty lines
          if (cleaned.length < 10) continue;

          // Stop if we hit another event summary (contains " ‚Äì " pattern)
          if (cleaned.includes(' ‚Äì ')) break;

          // Skip generic closing phrases
          const cleanedLower = cleaned.toLowerCase();
          if (excludePhrases.some(phrase => cleanedLower.includes(phrase))) {
            continue;
          }

          // Add this description line
          descriptionLines.push(cleaned);

          // Stop after collecting 2-3 lines or ~200 chars
          const combined = descriptionLines.join(' ');
          if (descriptionLines.length >= 2 || combined.length >= 200) break;
        }

        if (descriptionLines.length > 0) {
          return descriptionLines.join(' ').substring(0, 250);
        }
      }

      return null;
    }

    // Store for grouping events by location
    const locationGroups = {};

    // Add event to location group
    function addEventToLocationGroup(event, address, coords) {
      const locationKey = `${coords.lat},${coords.lng}`;

      if (!locationGroups[locationKey]) {
        locationGroups[locationKey] = {
          address: address,
          coords: coords,
          events: []
        };
      }

      locationGroups[locationKey].events.push(event);
    }

    // Create marker for a location with potentially multiple events
    function createMarkerForLocation(locationKey, locationData) {
      const { address, coords, events } = locationData;

      // Sort events by datetime (most recent first)
      events.sort((a, b) => b.datetime.localeCompare(a.datetime));

      // Use the most recent event to determine marker color
      const firstEventDetail = extractEventDetail(events[0].content, address);
      const detectedCategory = detectCategory(firstEventDetail);

      let markerIcon = markerIcons.blue;
      if (detectedCategory === 'medical') {
        markerIcon = markerIcons.yellow;
      } else if (detectedCategory === 'fire') {
        markerIcon = markerIcons.red;
      }

      const marker = L.marker([coords.lat, coords.lng], { icon: markerIcon });

      // Create popup content with ALL events at this location
      let popupContent = `<div class="popup-content">`;

      // Location at the top
      popupContent += `<p style="background: #f0f0f0; padding: 8px; margin: -10px -10px 10px -10px; border-bottom: 2px solid #666; font-weight: bold;"><strong>üìç Location:</strong> ${address}</p>`;

      if (events.length > 1) {
        popupContent += `<p style="background: #fffbcc; padding: 5px; margin: 0 0 10px 0; font-weight: bold;">${events.length} events at this location</p>`;
      }

      events.forEach((event, index) => {
        const eventDetail = extractEventDetail(event.content, address);
        const parsed = parseEventDetail(eventDetail);
        const description = extractDescription(event.content, address);

        if (index > 0) {
          popupContent += `<hr style="margin: 15px 0; border: none; border-top: 1px solid #ddd;">`;
        }

        popupContent += `
          <h3 style="margin-top: ${index > 0 ? '0' : '10px'};">${parsed.eventType}</h3>
          ${parsed.time ? `<p><strong>Time:</strong> ${parsed.time}</p>` : ''}
          <p><strong>Date:</strong> ${event.date}</p>
          ${description ? `<p>${description}</p>` : ''}
          <p><a href="${event.url}" target="_blank">View Full Report</a></p>
        `;
      });

      popupContent += `</div>`;

      marker.bindPopup(popupContent, { maxHeight: 400 });

      // Store all event data with marker
      marker.eventData = events[0]; // Store most recent for filtering
      marker.allEvents = events;
      marker.eventAddress = address;

      markers.push(marker);
      marker.addTo(markerLayer);
    }

    // Geocode a single address with delay
    async function geocodeWithDelay(address, delayMs) {
      await new Promise(resolve => setTimeout(resolve, delayMs));
      return await geocodeAddress(address);
    }

    // Update stats display
    function updateStats() {
      const visibleMarkers = markers.filter(marker => markerLayer.hasLayer(marker));
      const statsEl = document.getElementById('stats');
      if (statsEl) {
        statsEl.innerHTML =
          `<strong>Showing:</strong> ${visibleMarkers.length} of ${markers.length} locations`;
        console.log('Stats updated:', visibleMarkers.length, 'of', markers.length, 'visible');
      }
    }

    // Initialize map
    async function initMap() {
      // Center on Louisville, KY
      map = L.map('map').setView([38.2527, -85.7585], 12);

      // Add OpenStreetMap tiles
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
        maxZoom: 19
      }).addTo(map);

      // Add legend
      const legend = L.control({position: 'bottomright'});
      legend.onAdd = function(map) {
        const div = L.DomUtil.create('div', 'legend');
        div.innerHTML = `
          <h4>Event Categories</h4>
          <div class="legend-item">
            <i style="background: #2A81CB"></i>
            <span>Police</span>
          </div>
          <div class="legend-item">
            <i style="background: #CB2B3E"></i>
            <span>Fire & Rescue</span>
          </div>
          <div class="legend-item">
            <i style="background: #FFD326"></i>
            <span>Medical</span>
          </div>
        `;
        return div;
      };
      legend.addTo(map);

      // Create a layer group for markers
      markerLayer = L.layerGroup().addTo(map);

      // Process all events
      let allItems = [];

      eventsData.forEach(event => {
        const addresses = extractAddresses(event.content);
        addresses.forEach(address => {
          allItems.push({ event, address });
        });
      });

      console.log(`Found ${allItems.length} addresses from ${eventsData.length} events`);

      // Separate cached and uncached addresses
      const cachedItems = [];
      const uncachedItems = [];

      allItems.forEach(item => {
        if (geocodeCache[item.address]) {
          cachedItems.push(item);
        } else {
          uncachedItems.push(item);
        }
      });

      console.log(`Cached: ${cachedItems.length}, Need to geocode: ${uncachedItems.length}`);

      // Set default date range BEFORE adding markers (yesterday to today)
      const today = new Date();
      const yesterday = new Date(today.getTime() - 24 * 60 * 60 * 1000);

      const startDateEl = document.getElementById('startDate');
      const endDateEl = document.getElementById('endDate');

      if (startDateEl && endDateEl) {
        startDateEl.valueAsDate = yesterday;
        endDateEl.valueAsDate = today;

        // Add event listeners to date inputs
        startDateEl.addEventListener('change', applyFilters);
        startDateEl.addEventListener('input', applyFilters);
        endDateEl.addEventListener('change', applyFilters);
        endDateEl.addEventListener('input', applyFilters);

        console.log('Date filters initialized:', startDateEl.value, 'to', endDateEl.value);
      }

      // Process cached addresses immediately - add to location groups
      cachedItems.forEach(item => {
        const coords = geocodeCache[item.address];
        if (coords) {
          addEventToLocationGroup(item.event, item.address, coords);
        }
      });

      // Create markers from grouped locations
      Object.keys(locationGroups).forEach(locationKey => {
        createMarkerForLocation(locationKey, locationGroups[locationKey]);
      });

      // Apply initial filters to cached markers (dates are now set)
      applyFilters();

      // Process uncached addresses with delay (respecting rate limits)
      if (uncachedItems.length > 0) {
        for (let i = 0; i < uncachedItems.length; i++) {
          const item = uncachedItems[i];

          // Add delay only for new geocoding requests (1 per second)
          const coords = await geocodeWithDelay(item.address, i * 1000);

          if (coords) {
            addEventToLocationGroup(item.event, item.address, coords);

            // Create/update marker for this location
            const locationKey = `${coords.lat},${coords.lng}`;
            if (locationGroups[locationKey]) {
              // Remove old marker if exists
              const oldMarker = markers.find(m => m.eventAddress === item.address && m._latlng.lat === coords.lat && m._latlng.lng === coords.lng);
              if (oldMarker) {
                markerLayer.removeLayer(oldMarker);
                markers = markers.filter(m => m !== oldMarker);
              }
              // Create new marker with all events
              createMarkerForLocation(locationKey, locationGroups[locationKey]);
            }

            // Apply filters after each new marker
            applyFilters();
          }
        }
      }

      // Show stats when done
      setTimeout(() => {
        document.getElementById('stats').style.display = 'block';
        updateStats();
      }, uncachedItems.length > 0 ? 1000 : 100);
    }

    // Filter markers based on date range
    function applyFilters() {
      const startDateInput = document.getElementById('startDate');
      const endDateInput = document.getElementById('endDate');

      if (!startDateInput || !endDateInput) return;

      const startDate = startDateInput.value;
      const endDate = endDateInput.value;

      console.log('Filtering with dates:', startDate, 'to', endDate);

      markers.forEach(marker => {
        const event = marker.eventData;
        let show = true;

        // Date filter - use string comparison (works with YYYY-MM-DD format)
        if (startDate && event.date < startDate) {
          show = false;
        }
        if (endDate && event.date > endDate) {
          show = false;
        }

        if (show) {
          if (!markerLayer.hasLayer(marker)) {
            marker.addTo(markerLayer);
          }
        } else {
          if (markerLayer.hasLayer(marker)) {
            markerLayer.removeLayer(marker);
          }
        }
      });

      updateStats();
    }

    // Reset all filters
    function resetFilters() {
      // Clear date inputs
      document.getElementById('startDate').value = '';
      document.getElementById('endDate').value = '';

      // Show all markers
      markers.forEach(marker => {
        marker.addTo(markerLayer);
      });

      updateStats();
    }

    // Track user location marker
    let userLocationMarker = null;

    // Show user's current location on the map
    function showMyLocation() {
      // Check if geolocation is available
      if (!navigator.geolocation) {
        alert('Geolocation is not supported by your browser');
        return;
      }

      // Request user's location
      navigator.geolocation.getCurrentPosition(
        // Success callback
        function(position) {
          const lat = position.coords.latitude;
          const lng = position.coords.longitude;

          console.log('User location:', lat, lng);

          // Create a custom green marker for user location
          const userIcon = L.icon({
            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowSize: [41, 41]
          });

          // Remove existing user location marker if it exists
          if (userLocationMarker) {
            map.removeLayer(userLocationMarker);
          }

          // Add new marker at user's location
          userLocationMarker = L.marker([lat, lng], { icon: userIcon })
            .addTo(map)
            .bindPopup('<div class="popup-content"><h3>üìç Your Location</h3></div>')
            .openPopup();

          // Pan and zoom to user's location
          map.setView([lat, lng], 14);
        },
        // Error callback
        function(error) {
          let errorMsg = 'Unable to retrieve your location';

          switch(error.code) {
            case error.PERMISSION_DENIED:
              errorMsg = 'Location access denied. Please enable location permissions.';
              break;
            case error.POSITION_UNAVAILABLE:
              errorMsg = 'Location information is unavailable.';
              break;
            case error.TIMEOUT:
              errorMsg = 'Location request timed out.';
              break;
          }

          alert(errorMsg);
          console.error('Geolocation error:', error);
        },
        // Options
        {
          enableHighAccuracy: true,
          timeout: 5000,
          maximumAge: 0
        }
      );
    }

    // Initialize map when page loads
    document.addEventListener('DOMContentLoaded', initMap);
  </script>
</body>
</html>
